"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/plugin/index.ts
var plugin_exports = {};
__export(plugin_exports, {
  default: () => plugin_default
});
module.exports = __toCommonJS(plugin_exports);

// src/plugin/server/index.ts
var import_path2 = require("path");
var import_koa = __toESM(require("koa"));
var import_koa_bodyparser = __toESM(require("koa-bodyparser"));
var import_cors = __toESM(require("@koa/cors"));
var import_get_port = __toESM(require("get-port"));

// src/plugin/server/requests/get.ts
var fs = __toESM(require("fs/promises"));
var import_koa_router = __toESM(require("koa-router"));

// src/common/isNodeError.ts
function isNodeError(error) {
  return "code" in error;
}
var isNodeError_default = isNodeError;

// src/plugin/server/requests/get.ts
function createRoutes(resolvePath) {
  async function readFile2(path) {
    const data = await fs.readFile(path);
    return data;
  }
  async function readdir2(path, withFileTypes) {
    if (!withFileTypes) {
      const items2 = await fs.readdir(path);
      return items2;
    }
    const dirents = await fs.readdir(path, { withFileTypes: true });
    const items = [];
    dirents.forEach((dirent) => {
      const simpleDirent = {
        name: dirent.name,
        dir: dirent.isDirectory()
      };
      if (dirent.isFile() || dirent.isDirectory()) {
        items.push(simpleDirent);
      }
    });
    return items;
  }
  async function stat2(path) {
    const stats = await fs.stat(path);
    if (stats.isFile() || stats.isDirectory()) {
      const simpleStats = {
        ...stats,
        dir: stats.isDirectory()
      };
      return simpleStats;
    }
    throw new Error();
  }
  const router = new import_koa_router.default();
  router.get(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(decodeURIComponent(ctx.path));
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "readFile") {
        try {
          const response = await readFile2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              ctx.body = err.message;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
          return;
        }
      }
      if (ctx.query.cmd === "readdir") {
        if (ctx.query.withFileTypes) {
          try {
            const response = await readdir2(path, true);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        } else {
          try {
            const response = await readdir2(path);
            ctx.status = 200;
            ctx.body = response;
            return;
          } catch (err) {
            if (isNodeError_default(err)) {
              if (err.code === "ENOENT") {
                ctx.status = 404;
                return;
              }
              ctx.status = 400;
              ctx.body = err.message;
            }
            return;
          }
        }
      }
      if (ctx.query.cmd === "stat") {
        try {
          const response = await stat2(path);
          ctx.status = 200;
          ctx.body = response;
          return;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
              return;
            }
            ctx.status = 400;
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/post.ts
var fs2 = __toESM(require("fs/promises"));
var import_path = require("path");
var import_koa_router2 = __toESM(require("koa-router"));
function createRoutes2(resolvePath) {
  const router = new import_koa_router2.default();
  router.post(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(decodeURIComponent(ctx.path));
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "writeFile") {
        const dir = (0, import_path.dirname)(path);
        const data = ctx.request.body;
        try {
          try {
            await fs2.mkdir(dir, { recursive: true });
          } catch (err) {
          }
          await fs2.writeFile(path, data);
          ctx.status = 200;
        } catch (err) {
          ctx.status = 500;
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/requests/delete.ts
var fs3 = __toESM(require("fs/promises"));
var import_koa_router3 = __toESM(require("koa-router"));
function createRoutes3(resolvePath) {
  const router = new import_koa_router3.default();
  router.delete(/.*/, async (ctx) => {
    ctx.status = 500;
    ctx.body = "Relay server error";
    let path;
    try {
      path = resolvePath(decodeURIComponent(ctx.path));
    } catch (err) {
      if (isNodeError_default(err)) {
        ctx.status = 403;
        ctx.body = err.message;
      }
      return;
    }
    if (ctx.query.cmd) {
      if (ctx.query.cmd === "rm") {
        let recursive = false;
        let force = false;
        if (ctx.query.recursive)
          recursive = true;
        if (ctx.query.force)
          force = true;
        try {
          await fs3.rm(path, { recursive, force });
          ctx.status = 200;
        } catch (err) {
          if (isNodeError_default(err)) {
            if (err.code === "ENOENT") {
              ctx.status = 404;
            } else if (err.code === "ERR_FS_EISDIR") {
              ctx.status = 400;
            } else {
              ctx.status = 500;
            }
            ctx.body = err.message;
          }
        }
      }
    } else {
      ctx.status = 400;
      ctx.body = "Command query param not specified";
    }
  });
  return router.routes();
}

// src/plugin/server/index.ts
var FsServer = class {
  app;
  rootDir;
  activePort;
  options;
  server;
  constructor(options) {
    this.options = options;
    this.rootDir = (0, import_path2.resolve)(this.options.rootDir);
    const app = new import_koa.default();
    app.use((0, import_koa_bodyparser.default)({
      enableTypes: ["json", "text"]
    }));
    app.use((0, import_cors.default)());
    app.use(createRoutes(this.resolvePath));
    app.use(createRoutes2(this.resolvePath));
    app.use(createRoutes3(this.resolvePath));
    this.app = app;
  }
  async start(silent) {
    const port = await (0, import_get_port.default)({ port: this.options.port });
    this.server = this.app.listen(port);
    if (!silent) {
      console.log("\x1B[41m");
      console.log(`fs relay server is running on port ${port}`);
      console.log(
        "Please be careful since any requests to this server can modify your actual file system"
      );
      console.log(
        `\x1B[43m\x1B[30mThe relay server sees ${this.rootDir} as root. Everything outside this directory is safe`
      );
      console.log("\x1B[0m");
    }
    this.activePort = port;
  }
  stop() {
    var _a;
    (_a = this.server) == null ? void 0 : _a.close();
    this.server = void 0;
  }
  resolvePath = (path) => {
    let cleanPath = path;
    while (cleanPath.length > 0 && cleanPath.startsWith("/")) {
      cleanPath = cleanPath.substring(1);
    }
    const p = (0, import_path2.resolve)(this.rootDir, cleanPath);
    if (!p.startsWith(this.rootDir)) {
      throw new Error("ABOVEROOT");
    } else {
      return p;
    }
  };
};
var server_default = FsServer;

// src/plugin/Options.ts
var defaultOptions = {
  port: 7070,
  rootDir: ""
};
function resolveOptions(userOptiuons) {
  return Object.assign(defaultOptions, userOptiuons);
}

// src/plugin/index.ts
function VitePluginFs(userOptiuons = {}) {
  const options = resolveOptions(userOptiuons);
  const virtualModuleId = "virtual:fs";
  const resolvedVirtualModuleId = `\0${virtualModuleId}`;
  let server = null;
  let isProd = true;
  return [
    {
      name: "vite-plugin-fs",
      apply: "serve",
      config(_, env) {
        if (env.mode === "development") {
          isProd = false;
        }
        return {
          build: {
            rollupOptions: {
              external: [virtualModuleId]
            }
          },
          optimizeDeps: {
            exclude: [virtualModuleId]
          }
        };
      },
      async buildStart() {
        if (!isProd) {
          server = new server_default(options);
          await server.start();
        }
      },
      resolveId(id) {
        if (id === virtualModuleId) {
          return resolvedVirtualModuleId;
        }
        return null;
      },
      load(id) {
        if (typeof (server == null ? void 0 : server.activePort) === "number") {
          if (id === resolvedVirtualModuleId) {
            return `export const activePort = ${server.activePort}`;
          }
        }
        return null;
      },
      closeBundle() {
        server == null ? void 0 : server.stop();
      }
    },
    {
      name: "vite-plugin-fs",
      apply: "build",
      resolveId(id) {
        if (id === virtualModuleId) {
          this.error("virtual:fs imported in production code, that is not allowed. It is likely caused by importing vite-plugin-fs/browser. Please find a way not to do that, making a vite plugin is a great start.");
        }
        return null;
      }
    }
  ];
}
var plugin_default = VitePluginFs;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
